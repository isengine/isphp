У нас есть атрибуты с префиксом is-*

is-data - следит за значением, либо атрибут value, либо содержимое html/text, перехватывает значение и назначает его при изменениях
is-action - маркер действия, какое действие по идентификатору будет повешено сюда
is-data-from - то же, что is-data, но читаем информацию из атрибутов data-*
is-parent - назначает элемент dom-структуры в качестве родителя с опредленным именем

У нас есть множество родителей:

	item

Для каждого из них у нас записаны параметры:

	title
	value
	price
	price-old
	units

Также is-data-from создает следующие параметры:

	name
	step

У нас также есть действия:

	buy
	inc
	dec
	enter

Первые три висят на 'a', а последнее - на 'input'.

Мы можем создать экземпляр класса со всеми родителями, либо с указанием конкретного родителя:

	let i = new is.View();
	или
	let i = new is.View("item");

При этом, все экземпляры будут храниться внутри объекта. Даже если экземпляр один.
Доступ к экземплярам будет просто через свойство items:

	i.items

Доступ к конкретному экземпляру будет через ключ:

	i.items.key
	или
	i.items[key]

В экземпляре будут доступны следующие параметры:

	data - доступ к данным
	action - доступ к действиям

Параметр 'data' представляет собой объект, в котором содержатся:

	value - значение
	item - идентификатор объекта, по которому можно получить к нему доступ
	this - сам объект

Параметр 'action' представляет собой объект, в который вы можете задать доступные методы.
Для этого доступны следующие параметры:

	type - тип события
	callback - функция, которая будет вызываться

Функция может быть внешней, т.е. вызываться по имени функции, либо внутренней, т.е. анонимной.
Функция имеет следующие параметры:

	this - элемент, на который "повешено" событие
	parent - родительский элемент, который взят из is.item

Например, вы хотите, чтобы событие 'inc', привязанное к каждому экземпляру, реагировало на клик по элементу. Все просто:

	i.items.action.inc.type = "click";
	i.items.action.inc.callback = function() { this ... };
	или
	i.items.action.inc.callback = function(parent) { parent ... };
	или
	i.items.action.inc.callback = functionName();
	или
	i.items.action.inc.callback = functionName(parent);

Техническая сторона реализации

is.View = class {
	
	__constructor(parent = null) {
		
		if (!parent) {
			здесь смотрим всю dom и создаем объекты внутри класса с любыми значениями атрибута '[is-parent="..."]'
		} else {
			здесь мы также смотрим всю dom и выбираем объекты только с атрибутом '[is-parent="' + parent + '"]'
		}
		
		// каждый созданный объект должен иметь наследование от родительского класса, например is.Parent
		
	}
	
}

is.Parent = class {
	
	var
		data = {},
		action = {};
	
}

Эти классы должны наследоваться от своих родителей, т.е.:

is.Data = class {
	
	var
		value,
		item;
		//this
	
}

is.Aсtion = class {
	
	var
		type,
		callback;
		//this
	
}

В ходе создания экземпляра объекта должны также создаваться события,
которые будут прослушивать все экземпляры и реагировать на них.

Может создаваться такая история, когда создаются два разных экземпляра,
но они должы полностью копировать друг друга. Например, это может быть
товар из каталога и такой же точно товар, но в корзине.

При изменении одного, точно так же должен изменяться и другой.

Для этого необходимо присвоить экземплярам идентификаторы. Если он
не будет присвоен, то экземпляр будет доступен по цифровому индексу 0, 1 и т.д.

Идентификатор присваивается через is-name. Таким образом, вы можете назначить
сколько угодно одинаковых экземпляров. И каждый из них будет вступать в реакцию
с системой.

Также при изменении значения экземпляра, например:

	is.item.data.price = 150;
	или
	is.item.data.value++;

Должно меняться и отображение этих данных на экране.

На данный момент такой фреймворк будем реализовывать на jquery.
Затем, возможно, перейдем на нативный js.
