У нас есть атрибуты с префиксом is-*

is-data - следит за значением, либо атрибут value, либо содержимое html/text, перехватывает значение и назначает его при изменениях
is-action - маркер действия, какое действие по идентификатору будет повешено сюда
is-data-from - то же, что is-data, но читаем информацию из атрибутов data-*
is-parent - назначает элемент dom-структуры в качестве родителя с опредленным именем

У нас есть множество родителей:

	item

Для каждого из них у нас записаны параметры:

	title
	value
	price
	price-old
	units

Также is-data-from создает следующие параметры:

	name
	step

У нас также есть действия:

	buy
	inc
	dec
	enter

Первые три висят на 'a', а последнее - на 'input'.

Мы можем создать экземпляр класса со всеми родителями, либо с указанием конкретного родителя:

	let i = new is.View();
	или
	let i = new is.View("item");

При этом, все экземпляры будут храниться внутри объекта. Даже если экземпляр один.
Доступ к экземплярам будет просто через свойство items:

	i.items

Доступ к конкретному экземпляру будет через ключ:

	i.items.key
	или
	i.items[key]

В экземпляре будут доступны следующие методы:

	data - доступ к данным
	action - доступ к действиям

Метод 'data' представляет собой объект, в котором содержатся ключи и значения, общие для всего родителя и всех его экземпляров.

Метод 'action' позволяет задать обработчики событий. Для этого доступны следующие параметры:

	name - название элемента по is-action
	type - тип события
	callback - функция, которая будет вызываться

Функция может быть внешней, т.е. вызываться по имени функции, либо внутренней, т.е. анонимной. Функция не предусматривает параметров.

Например, вы хотите, чтобы событие 'inc', привязанное к каждому экземпляру, реагировало на клик по элементу. Все просто:

	i.items.action.inc.type = "click";
	i.items.action.inc.callback = function() { this ... };
	или
	i.items.action.inc.callback = function(parent) { parent ... };
	или
	i.items.action.inc.callback = functionName();
	или
	i.items.action.inc.callback = functionName(parent);

Техническая сторона реализации

В ходе создания экземпляра объекта должны также создаваться события,
которые будут прослушивать все экземпляры и реагировать на них.

Может создаваться такая история, когда создаются два разных экземпляра,
но они должы полностью копировать друг друга. Например, это может быть
товар из каталога и такой же точно товар, но в корзине.

При изменении одного, точно так же должен изменяться и другой.

Для этого необходимо присвоить экземплярам идентификаторы. Если он
не будет присвоен, то экземпляр будет доступен по цифровому индексу 0, 1 и т.д.

Идентификатор присваивается через is-name. Таким образом, вы можете назначить
сколько угодно одинаковых экземпляров. И каждый из них будет вступать в реакцию
с системой.

Также при изменении значения экземпляра, например:

	is.item.data("price", 150);
	или
	is.item.data("value", is.item.data("value") + 1);

Должно меняться и отображение этих данных на экране.

На данный момент такой фреймворк будем реализовывать на jquery.
Затем, возможно, перейдем на нативный js.

===

Пример использования

let a = new isView("asd");
console.log(a);

// получение данных

// получение всех значений
console.log( a._data );
console.log( a.data() );

// получение значения по ключу
console.log( a.data("value") );
console.log( a.data().value );
console.log( a.data()["value"] );
console.log( a._data.value );
console.log( a._data["value"] );

// синхронизация данных

// для всех данных

a.refresh()

// для определенных данных

a.refresh("value")

// изменение данных
// работает только для определенных данных

a.data("value", 10)

// назначение обработчиков
// обработчики назначаются по name на is-action, содержащие их
// вторым аргументом идет тип действия,
// третим - функция

// особенность данных обработчиков в том,
// что они также работают для динамически созданных объектов

// следующие два примера полностью идентичны, разница в короткой и длинной записях
// здесь текущее значение данных по ключу "max" увеличивается на единицу

a.action("inc", "click", () => a.value("max", (i) => ++i));

a.action("inc", "click", function(){
	a.value("max", (i) => ++i);
});

// следующие два примера полностью идентичны, разница в короткой и длинной записях
// здесь текущее значение данных по ключу "max" увеличивается на значение данных по ключу "step"

a.action("inc", "click", function(){
	let v = a.data("max");
	let s = a.data("step");
	v = parseFloat(v);
	s = parseFloat(s);
	a.data("max", v + s);
});

a.action("inc", "click", () => a.data("max", parseFloat(a.data("max")) + parseFloat(a.data("step"))));

// для получения всех элементов

let a = new isView();

// при этом, внутри объекта создается массив items
// он обычно пустой, если было вызвано создание только одних экземпляров
// но теперь он будет заполнен объектами isView с ключами родителей,
// а остальные данные будут пустыми

// для доступа к этим объектам, можно использовать такие вызовы

a.items.asd.data("max", 54.2);
a.items.asd.action("inc", "click", () => a.items.asd.value("max", (i) => ++i));
a.items.asd.action("dec", "click", () => a.items.asd.value("max", (i) => --i));
a.items.qwe.data("max", 5.2);
a.items.qwe.action("inc", "click", () => a.items.qwe.value("max", (i) => ++i));
a.items.qwe.action("dec", "click", () => a.items.qwe.value("max", (i) => --i));

// для автоматизации процесса, особенно когда родителей много,
// можно перебирать объекты в цикле
// при этом this будет ссылкой на текущий внутренний объект,
// а первый аргумент будет ключом

let start = {
	asd : 54.2,
	qwe : 5.8
}
$.each(
	a.items,
	function(i){
		this.data("max", start[i]);
		this.action("inc", "click", () => this.value("max", (i) => ++i));
		this.action("dec", "click", () => this.value("max", (i) => --i));
	}
);
